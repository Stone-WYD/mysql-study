{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"76QL2","children":{"0":{"objectClass":"MindNode","ID":"GE9U5","text":"索引的建立","remark":"见索引的思维导图","remarkDisplay":true},"1":{"objectClass":"MindNode","ID":"SQ341","children":{"0":{"objectClass":"MindNode","ID":"8UYEM","text":"空间代价","remark":"每个索引都是一个B+树，需要占用一定的空间","remarkDisplay":true},"1":{"objectClass":"MindNode","ID":"MRUQ3","children":{"0":{"objectClass":"MindNode","ID":"3Y5P6","text":"对数据增删改时需要维护索引"},"1":{"objectClass":"MindNode","ID":"TL58V","text":"索引越多，执行查询前的执行计划就越耗时"},"objectClass":"NSArray"},"text":"时间代价"},"objectClass":"NSArray"},"text":"索引的代价","shrink":true},"2":{"objectClass":"MindNode","ID":"21DN6","children":{"0":{"objectClass":"MindNode","ID":"TK30Z","text":"单点扫描区间"},"1":{"objectClass":"MindNode","ID":"972KM","text":"范围扫描区间"},"2":{"objectClass":"MindNode","ID":"WL8DE","children":{"0":{"objectClass":"MindNode","ID":"4I30Q","text":"in ：相当于多\n个 = 用 or 连接起来"},"1":{"objectClass":"MindNode","ID":"2DC0J","text":"!=：等用于全表扫描 "},"2":{"objectClass":"MindNode","ID":"JEQM8","text":"like：key1 like 'a%'等同于\n扫描区间[ 'a', 'b' ) "},"objectClass":"NSArray"},"text":"一些语句的作用"},"3":{"objectClass":"MindNode","ID":"V70J0","children":{"0":{"objectClass":"MindNode","ID":"48I6X","text":"通过索引可以确定","remark":"通过索引能找到合适的扫描区间，如果有其他条件，回表查找并对比找出记录","style2":{"objectClass":"NSDictionary","color":"#000000"},"remarkDisplay":true},"1":{"objectClass":"MindNode","ID":"5C93U","text":"通过索引无法确定","remark":"加上索引列的搜索条件，结果发现查找范围还是全表，那么不如直接全表搜索，因为查找二级索引会消耗性能","remarkDisplay":true},"objectClass":"NSArray"},"text":"扫描区间的确定"},"objectClass":"NSArray"},"text":"扫描区间和边界条件（Where）"},"3":{"objectClass":"MindNode","ID":"81IC1","children":{"0":{"objectClass":"MindNode","ID":"62W44","text":"order by 列顺序如果跟联合索引列顺序一样，则联合索引中找到第一个符合条件的数据后，单向以此回表取出数据即可。"},"1":{"objectClass":"MindNode","ID":"KA8E3","children":{"0":{"objectClass":"MindNode","ID":"2F1Y8","text":"列顺序要一致"},"1":{"objectClass":"MindNode","ID":"8JC5J","text":"每个列的排序规则要一致","remark":"要么都ASC，要么都DESC","remarkDisplay":true},"2":{"objectClass":"MindNode","ID":"BMW04","children":{"0":{"objectClass":"MindNode","ID":"51471","text":"ASC,DEC混用"},"1":{"objectClass":"MindNode","ID":"33Q8K","text":"排序列包含非同一个索引的列"},"2":{"objectClass":"MindNode","ID":"RN1WQ","text":"排序列是某个联合索引的索引列，但\n是这些排序列在联合索引中并不连续"},"3":{"objectClass":"MindNode","ID":"NK3H2","text":"用来形成扫描区间的索引列与排序列不同"},"4":{"objectClass":"MindNode","ID":"3K32O","text":"排序列不是以单独列名的形式出现"},"objectClass":"NSArray"},"text":"不能使用索引排序的情况"},"objectClass":"NSArray"},"text":"注意事项"},"objectClass":"NSArray"},"text":"索引用于排序（Order By）","shrink":true,"remarkDisplay":true},"4":{"objectClass":"MindNode","ID":"U660U","children":{"0":{"objectClass":"MindNode","ID":"XNO88","children":{"0":{"objectClass":"MindNode","ID":"7TF64","text":"先按照key_part1分组"},"1":{"objectClass":"MindNode","ID":"M3PE5","text":"每个key_part1值相同的分组下，\n再按key_part2分组"},"2":{"objectClass":"MindNode","ID":"E21J0","text":"在上一步的基础上，再按key_part3分组"},"3":{"objectClass":"MindNode","ID":"2338E","text":"总结来理解：把key_part1, key_part2, \nkey_part3当作主键或者联合索引按大小排序，主键或索引相同的放一起算作一个组 "},"objectClass":"NSArray"},"text":"group by key_part1,\n key_part2, key_part3的含义"},"1":{"objectClass":"MindNode","ID":"CYIKP","text":"通过上面的理解，可以发现如果分组和索引B+树是一致的，那可以直接复用"},"objectClass":"NSArray"},"text":"索引用于分组（Group By）","shrink":true},"5":{"objectClass":"MindNode","ID":"Q4Q24","children":{"0":{"objectClass":"MindNode","ID":"QN51M","text":"二级索引确定范围后，逐条查找主键"},"1":{"objectClass":"MindNode","ID":"4B7M8","text":"如果主键对应的记录在聚簇索引中已经被加载到内存中，那还容易查找","maxWidthLine":479},"2":{"objectClass":"MindNode","ID":"62OWX","text":"如果没有，那就会产生一些随机的I/O(通过二级索引找到的主键是随机的)。","maxWidthLine":512.0625},"3":{"objectClass":"MindNode","ID":"LL074","children":{"0":{"objectClass":"MindNode","ID":"4F8FU","text":"判断该不该用索引，该用什么索引"},"objectClass":"NSArray"},"text":"查询优化器"},"objectClass":"NSArray"},"text":"回表的代价","shrink":true},"6":{"objectClass":"MindNode","ID":"1YGC6","children":{"0":{"objectClass":"MindNode","ID":"Q5A4B","text":"只为搜索(where)，排序(order by)，分组(group by)的列创建索引"},"1":{"objectClass":"MindNode","ID":"S4258","text":"索引列中不重复值所占比例应该尽量小"},"2":{"objectClass":"MindNode","ID":"35271","text":"索引列的类型应尽量小"},"3":{"objectClass":"MindNode","ID":"F4J22","children":{"0":{"objectClass":"MindNode","ID":"63YUX","text":"eg: alter table single_table add index idx_key1(key1(10));"},"1":{"objectClass":"MindNode","ID":"5M677","text":"在字符串大小可能比较大但是又需要该列当索引时可以使用。"},"2":{"objectClass":"MindNode","ID":"5DI7M","text":"使用索引前缀作为索引后，便不再能用该索引排序了。"},"objectClass":"NSArray"},"text":"为列前缀建立索引"},"4":{"objectClass":"MindNode","ID":"A8H7X","children":{"0":{"objectClass":"MindNode","ID":"1T5JS","text":"select 中的查询列，如果都是索引中的列，那么在使用二级索引的时候，可以省去回表的操作","maxWidthLine":325},"1":{"objectClass":"MindNode","ID":"8868I","text":"select 中的列最好不要用*，而是只查询需要的列，查的无用信息越多，I/O读取的信息就越多，对性能是一种损耗"},"objectClass":"NSArray"},"text":"索引覆盖"},"5":{"objectClass":"MindNode","ID":"MF94C","text":"让索引列以列名的形式在搜索条件中单独出现","remark":"否则索引可能无法生效。","maxWidthLine":494,"remarkDisplay":true},"6":{"objectClass":"MindNode","ID":"2P321","text":"新插入的记录最好主键逐渐递增","remark":"可能的话，可以尽量使用id auto increment作为主键","remarkDisplay":true},"7":{"objectClass":"MindNode","ID":"5PHF1","text":"避免冗余和重复索引"},"objectClass":"NSArray"},"text":"更好地创建和使用索引","shrink":true},"objectClass":"NSArray"},"text":"索引的使用"},"ID":"G384Y","style":100,"lineKeepThin":true}