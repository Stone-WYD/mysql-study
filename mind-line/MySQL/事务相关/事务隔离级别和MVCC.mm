{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"7PW8B","children":{"0":{"objectClass":"MindNode","ID":"89BMT","text":"redo日志，undo日志，可以确保原子性"},"1":{"objectClass":"MindNode","ID":"KXX11","children":{"0":{"objectClass":"MindNode","ID":"G9V35","children":{"0":{"objectClass":"MindNode","ID":"JC41S","text":"事务同时执行后，原本的一致性被破坏了"},"1":{"objectClass":"MindNode","ID":"48887","text":"事务同时执行时 ，如果中间还有回滚操作，已完成的事务也会受到影响"},"2":{"objectClass":"MindNode","ID":"IS4U4","children":{"0":{"objectClass":"MindNode","ID":"2P8RV","text":"w1[x=1]w2[x=2]w2[y=2]c2w1[y=1]c1"},"1":{"objectClass":"MindNode","ID":"92FY5","text":"w1[x=2]w2[x=3]w2[y=3]c2a1"},"objectClass":"NSArray"},"text":"例子"},"objectClass":"NSArray"},"text":"脏写"},"1":{"objectClass":"MindNode","ID":"GX5KQ","children":{"0":{"objectClass":"MindNode","ID":"A5S9E","text":"一个事务读到另一个未提交事务修改过的数据"},"1":{"objectClass":"MindNode","ID":"122A4","children":{"0":{"objectClass":"MindNode","ID":"L65Z8","text":"w1[x=1]r2[x=1]r2[y=0]c2w1[y=1]c1"},"1":{"objectClass":"MindNode","ID":"7V6XQ","text":"w1[x=1]r2[x=1]r2[y=0]c2w1[y=1]a1","remark":"因为T1回滚了，所以T2读取了一个不存在的数据","remarkDisplay":true},"objectClass":"NSArray"},"text":"例子"},"objectClass":"NSArray"},"text":"脏读"},"2":{"objectClass":"MindNode","ID":"F1SF6","children":{"0":{"objectClass":"MindNode","ID":"70B56","text":"一个事务修改了另一个未提交事务读取的数据"},"1":{"objectClass":"MindNode","ID":"I5ZE8","children":{"0":{"objectClass":"MindNode","ID":"R1V39","text":"r1[x=0]w2[x=1]w2[y=1]c2r1[y=1]c1 "},"1":{"objectClass":"MindNode","ID":"8422M","text":"r1[x=0]w2[x=1]w2[y=1]c2r1[x=1]c1 "},"objectClass":"NSArray"},"text":"例子"},"objectClass":"NSArray"},"text":"不可重复读"},"3":{"objectClass":"MindNode","ID":"7M08G","children":{"0":{"objectClass":"MindNode","ID":"D4ZBY","text":"一个事务查出一些符合某些条件的记录，在该记录未提交时，另一个事务写入了符合上述查找条件的记录，然后第一个事务进行第二次相同的查找后，发现查找到的数据变多了"},"objectClass":"NSArray"},"text":"幻读"},"4":{"objectClass":"MindNode","ID":"EUG73","text":"脏写、脏读、不可重复读针对的是一条记录的项，幻读针对的是一条或多条记录"},"5":{"objectClass":"MindNode","ID":"S18R4","children":{"0":{"objectClass":"MindNode","ID":"D72DC","text":"READ UNCOMMITTED"},"1":{"objectClass":"MindNode","ID":"2C232","text":"READ COMMITTED"},"2":{"objectClass":"MindNode","ID":"NC410","text":"REPEATABLE READ"},"3":{"objectClass":"MindNode","ID":"4M9KZ","text":"SERIALIZABLE"},"4":{"objectClass":"MindNode","ID":"OUKG5","text":"都能防止脏写"},"5":{"objectClass":"MindNode","ID":"99FI2","text":"","imageName":"DVSYGW24WR.png","imageSize":{"objectClass":"CGSize","width":1091,"height":370},"imageResize":{"objectClass":"CGSize","width":296,"height":100.38496791934008}},"objectClass":"NSArray"},"text":"SQL标准的四种隔离级别"},"objectClass":"NSArray"},"text":"事务并发执行会遇到的一致性问题","remark":"例子说明：x、y相等，初始x=y=0；r: 读操作，w: 写操作，a: 终止，c：提交，操作后面的数字表示事务number","remarkDisplay":true},"2":{"objectClass":"MindNode","ID":"VE5RG","children":{"0":{"objectClass":"MindNode","ID":"K4S72","text":"版本链"},"1":{"objectClass":"MindNode","ID":"N0UW5","children":{"0":{"objectClass":"MindNode","ID":"IBJ31","text":"READ UNCOMMITTED，直接读版本链的最新版本"},"1":{"objectClass":"MindNode","ID":"4G5Q3","text":"SERIALIZABLE 所有事务互斥进行，同一时间只能进行一个事务，通过加锁实现"},"2":{"objectClass":"MindNode","ID":"983SQ","text":"READ COMMITTED 和 REPEATABLE READ 通过ReadVIew来实现隔离"},"objectClass":"NSArray"},"text":"针对不同隔离级别\n的处理方式","shrink":true},"2":{"objectClass":"MindNode","ID":"FSGRD","lineColor":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"I75PO","children":{"0":{"objectClass":"MindNode","ID":"7RF28","text":"在生成的ReadView时，当前系统中活跃的读写事务的事务 id 列表"},"objectClass":"NSArray"},"text":"m_ids"},"1":{"objectClass":"MindNode","ID":"SI15Q","children":{"0":{"objectClass":"MindNode","ID":"O7T1H","text":"在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务id;也就m_ids中的最小值"},"objectClass":"NSArray"},"text":"min_trx_id"},"2":{"objectClass":"MindNode","ID":"E2UB6","children":{"0":{"objectClass":"MindNode","ID":"68052","text":"在生成ReadView时，系统应该分配给下一个事务的事务id"},"objectClass":"NSArray"},"text":"max_trx_id"},"3":{"objectClass":"MindNode","ID":"45B7I","children":{"0":{"objectClass":"MindNode","ID":"E3I47","text":"生成该ReadView的事务的事务id"},"objectClass":"NSArray"},"text":"creator_trx_id"},"4":{"objectClass":"MindNode","ID":"W6FAR","children":{"0":{"objectClass":"MindNode","ID":"2586E","text":"如果被访问版本的trx_id和ReadView中的creator_trx_id相同，则可以访问"},"1":{"objectClass":"MindNode","ID":"72Z75","text":"被访问版本trx_id小于ReadView的min_trx_id,表明该版本在生成ReadView时已经被提交，所以该版本可以被当前事务访问"},"2":{"objectClass":"MindNode","ID":"03I43","text":"被访问版本trx_id大于等于ReadView中的max_trx_id,表明生成版本在事务生成ReadView之后才开启，则该版本不能被当前事务访问"},"3":{"objectClass":"MindNode","ID":"3E3E3","text":"被访问版本trx_id 在ReadView的max_trx_id和 min_trx_id之间，则判断trx_id是否在m_ids中，如果在，说明ReadView创建时，该版本事务处于活跃中，则不能访问，否则可以。"},"objectClass":"NSArray"},"text":"使用ReadView来判断\n某个版本是否可见"},"5":{"objectClass":"MindNode","ID":"W74L0","children":{"0":{"objectClass":"MindNode","ID":"596FC","text":"READ COMMITED 每次读取数据前都会生成一个ReadView"},"1":{"objectClass":"MindNode","ID":"H4257","text":"REPEATABLE READ 在第一次读取数据时生成一个ReadView"},"2":{"objectClass":"MindNode","ID":"7DXX3","children":{"0":{"objectClass":"MindNode","ID":"859Q3","text":"无论是READ COMMITED 还是 REPEATABLE READ，两者都是对查找到的一条记录建立的ReadView。"},"1":{"objectClass":"MindNode","ID":"CCI8U","text":"所以他们对第二次查询新出现的记录，都会新建一个ReadView，而最新的访问版本显然小于min_trx_id，所以会被读出来，然后就出现了幻读。"},"objectClass":"NSArray"},"text":"对幻读现象两者都无效原因分析："},"objectClass":"NSArray"},"text":"生成时机"},"objectClass":"NSArray"},"text":"ReadView","remark":"补充：只有在进行增删改的操作时，才会有给一个事务分配事务id，但是系统会给读事务分配默认为0的事务id","remarkDisplay":true},"3":{"objectClass":"MindNode","ID":"7JOT1","lineColor":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"6HX8J","text":"二级索引页面的Page Header 的 PAGE_MAX_TRX_ID属性会记录下最近修改该页面事务的事务id"},"1":{"objectClass":"MindNode","ID":"S871Q","children":{"0":{"objectClass":"MindNode","ID":"84D7F","text":"若min_trx大，则说明最近的修改可见，直接取出结果返回给客户端"},"1":{"objectClass":"MindNode","ID":"7EBMJ","text":"若步min_trx小，则回表查找记录，再按照前述操作查找到正确的版本记录"},"objectClass":"NSArray"},"text":"当有查询二级索引的事务到来时，\n会比较ReadView 中 min_trx_id与PAGE_MAX_TRX_ID的大小。"},"objectClass":"NSArray"},"text":"二级索引与MVCC"},"objectClass":"NSArray"},"text":"MVCC原理","remark":"Multi- Version Concurrency Control","remarkDisplay":true},"3":{"objectClass":"MindNode","ID":"83X5N","children":{"0":{"objectClass":"MindNode","ID":"O37QU","children":{"0":{"objectClass":"MindNode","ID":"923TG","text":"所以，只要系统最早产生的ReadView不再访问它们，则它们就可以被删除了"},"objectClass":"NSArray"},"text":"这两者是为了MVCC才存在的，不\n然可以在事务提交时就删除的"},"1":{"objectClass":"MindNode","ID":"FW73W","text":"每个回滚段中，update 组的 undo日志，会形成一个 history 链条，该链条按照事务no排序","maxWidthLine":340},"2":{"objectClass":"MindNode","ID":"37U9F","text":"ReadView也有一个按照执行时间连成的一个链表，此处称为rv链"},"3":{"objectClass":"MindNode","ID":"JQMT3","children":{"0":{"objectClass":"MindNode","ID":"928V5","text":"rv链的no值较大时，则将undo日志删除，mark记录删除"},"objectClass":"NSArray"},"text":"purse操作时，比较rv链最后的一个节点跟各个回滚段中的hisory链的事务no值"},"4":{"objectClass":"MindNode","ID":"KY214","text":"事务no：记录事务提交顺序","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"purse：删除没用的undo日志\n和被mark了删除标记的记录"},"objectClass":"NSArray"},"text":"事务隔离级别和MVCC"},"ID":"26SD5","style":100,"lineKeepThin":true}